<?xml version="1.0" encoding="utf-8"?>

<!-- Permission is granted to copy, distribute and/or modify this document -->
<!-- under the terms of the GNU Free Documentation License, Version 1.3 or -->
<!-- any later version published by the Free Software Foundation; with the -->
<!-- Invariant Sections being ``GNU General Public License'', with the -->
<!-- Front-Cover Texts being ``A GNU Manual'', and with the Back-Cover Texts -->
<!-- as in (a) below.  A copy of the license is included in the section -->
<!-- entitled ``GNU Free Documentation License''. -->
<!--  -->
<!-- (a) The FSF's Back-Cover Text is: ``You have the freedom to -->
<!-- copy and modify this GNU manual.  Buying copies from the FSF -->
<!-- supports it in developing GNU and promoting software freedom.'' -->

<chapter xmlns="http://docbook.org/ns/docbook"
	 xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0">
  <title>AgsAudio a container of AgsChannel</title>
  <para>
    AgsAudio contains a pointer to your notation and automation data. It has its
    own recall context, AgsRecallAudio. It organizes your recycling contices and
    thus having an associated AgsRecallID for running contices. Further AgsAudio
    is your topmost nesting level of AgsAudioSignal. You might traverse the layers
    in following order:
  </para>

  <orderedlist numeration="lowerroman">
    <listitem>
      AgsAudio
    </listitem>
    <listitem>
      AgsChannel
    </listitem>
    <listitem>
      AgsRecycling
    </listitem>
    <listitem>
      AgsAudioSignal
    </listitem>
  </orderedlist>

  <para>
    AgsAudioSignal keeps your audio data as a GList of buffers. AgsRecycling is your
    nested tree to AgsChannel, giving you the opportunity to emit ::add_audio_signal
    or ::remove_audio_signal by producer and havig many consumers. AgsChannel is your
    opposite to an audio channel representing a single line. AgsAudio keeps track of
    all of them. You might want to add your audio object to an AgsSoundcard.
  </para>

  <para>
    You may resize the count of pads or audio channels with ags_audio_set_pads() and
    ags_audio_set_audio_channels(). Like in the following example the channels are
    adjusted and notation is added.
  </para>

  <example>
    <title>Using AgsAudio</title>
    <programlisting language="C">
<xi:include href="../listings/audio.c" parse="text" />
    </programlisting>
  </example>

  <sect1>
    <title>AgsRecallID and AgsRecyclingContext</title>
    <para>
      As mentioned previously in this chapter AgsAudio organizes your recall ids and
      recycling contices. The following functions are here to add and remove them.
    </para>
    
    <itemizedlist mark='bullet'>
      <listitem>
	ags_audio_add_recall_id()
      </listitem>
      <listitem>
	ags_audio_remove_recall_id()
      </listitem>
      <listitem>
	ags_audio_add_recycling_context()
      </listitem>
      <listitem>
	ags_audio_remove_recycling_context()
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Dealing with recalls</title>
    <para>
      Since AgsAudio is your entry point to do sound processing there are some useful
      functions to set it up, but later on them. Instances of AgsRecallAudio base object
      may be added or removed with ags_audio_add_recall() and ags_audio_remove_recall().
    </para>
    
    <para>
      You can initialize the sound processing tree with ags_audio_recursive_play_init().
      This invokes successive ags_audio_init_recall(), ags_channel_init_recall() and related
      within your tree.
    </para>

    <para>
      The following signals are triggered during playback ::play, ::tact and ::done - 
      ::cancel and ::remove during termination.
    </para>
  </sect1>

  <sect1>
    <title>Open audio files</title>
    <para>
      There is a handy function called ags_audio_open_files() taking as parameter filenames
      as GSList, overwrite_channels and create_channels as boolean. Filenames is a single
      linked list of strings, overwrite_channels means use pre-allocated channels and
      create_channels to allow instantiate new channels. The boolean parameters can be combined
      as you want.
    </para>
  </sect1>
</chapter>
